# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel

Gluon Documentation
Last Updated: 2021-02-17 18:32:18 UTC
Table of Contents
1. Introduction
2. Getting Started
2.1. Requirements
2.2. IDE Plugins
2.3. Gluon Start
2.4. Maven Archetype
2.5. Adding your license
2.6. IDE Live templates
3. IDE Plugins
3.1. The Gluon Plugin for IntelliJ IDEA
3.2. The Gluon Plugin for NetBeans
3.3. The Gluon Plugin for Eclipse
4. The Gluon Client plugin for Maven
4.1. Apply the plugin
4.2. Goals
4.3. Run the samples
4.4. Configuration
4.5. Config files
4.6. Release Configuration
5. Platforms
5.1. Linux
5.2. Mac OS
5.3. Windows
5.4. Android
5.5. iOS
5.6. JavaFX on Embedded
6. User Interface (UI)
6.1. Glisten APIs
6.2. Glisten CSS Overview
6.3. Release Notes
7. Device Interface
7.1. Using Attach
7.2. Services Overview
7.3. Building Attach
8. Data Binding
8.1. File provider
8.2. REST provider
8.3. Deep Dive
9. CloudLink
9.1. Application Registration
9.2. Data Storage
9.3. Remote Functions
9.4. User Management
9.5. Media Management
9.6. Usage Analytics
9.7. Push Notifications
10. Samples
11. Scene Builder
11.1. Installation
11.2. Library Manager
11.3. Custom Panel
11.4. Developing Applications Using Gluon
12. Conclusion
1. Introduction
Gluon provides an easy and modern approach for developing Java Client applications. These applications can run on the JVM or can be converted to a platform specific native-images which have lighting fast startup and takes a fraction of space. Moreover, applications can also be targeted to Android, iOS, and embedded apart from all the desktop environments.

Gluon provides all the tools necessary to build these applications including, but not limited to, build tools, IDE plugins, UI library, cloud connectivity, data-binding etc.

2. Getting Started
Any Java application can be converted to a native application for a specific platform using Gluon technology. This platform specific application has much faster startup time, since the JVM no longer needs to be started. The resulting application will be entirely integrated into the native operating system.

An easy way to get started is to use the just add Gluon Client plugin to your Java application. Gluon Client plugin leverages GraalVM and OpenJDK by compiling the Java Client application and all its required dependencies into native code, so that it can be directly executed as a native application on the target platform.

At this moment, Gluon supports the following target platforms:

Linux

Mac OS X

Windows

iOS

Android

2.1. Requirements
Gluon applications can be developed, run, and tested on any desktop and embedded platform using the latest JDK.

Platform specific requirements for creation and deployment of native-images is discussed in depth in the platforms section.
2.2. IDE Plugins
At Gluon, we introduced IDE plugins to help developers get started with Gluon as quickly as possible. The plugin aids in creating a Gluon application project inside your IDE.

At present, we support NetBeans, IntelliJ IDEA and Eclipse.

You can read more about the IDE plugins in the IDE Plugins section of the documentation.

2.3. Gluon Start
Gluon Start is a website which enables you to generate the structure and skeleton of your Java client application. You can configure the following properties of the application:

Name, groupId and artifactId to use for the generated Maven project

JavaFX version and modules required by the project

Gluon Mobile stack to include in the project. For example, Glisten (for the UI toolkit) and Gluon Maps can be selected to be used in the same project

Gluon Attach services required in the project

If the application needs a flexible and secure way to connect to an existing or new backend or cloud service, Gluon CloudLink can be selected as well

All options are easily selectable and Gluon Start will generate the project with correct dependencies for you!

2.4. Maven Archetype
A simple Gluon application can be created by using the Client Maven Archetype for simple Gluon Mobile application.

For example:

mvn archetype:generate \
        -DarchetypeGroupId=com.gluonhq \
        -DarchetypeArtifactId=client-archetype-mobile \
        -DarchetypeVersion=0.0.2 \
        -DgroupId=com.gluonhq  \
        -DartifactId=gluon-mobile-sample \
        -Dversion=1.0.0-SNAPSHOT \
        -Djavafx-version=15
2.5. Adding your license
Some Gluon components require a license in certain circumstances. Check https://gluonhq.com/pricing/ for more information

After you have created the project or downloaded an existing one, there are 2 ways of adding your license:

1. Using an annotation:

Add your valid license key to your main application class using the @License annotation like this:

import com.gluonhq.charm.glisten.license.License;

@License(key="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX")
public class HelloWorld extends MobileApplication {
    ...
}
2. Using a license file:

Add a file called gluonmobile.license to your resources and add your valid license key as the content. This method allows you to keep your license private by excluding it from your source version control system.

src/main/resources/gluonmobile.license

XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
Licenses are validated online once per application install. If for some reason the license service can’t be contacted, your end-users won’t be annoyed by the popup, but the license check will be retried each time the application starts until successful.

2.6. IDE Live templates
A live template specifies an abbreviation which auto-completes a large chunk of code for you. Live templates for IntelliJ IDEA IDE has been defined to create JavaFX properties, including getters, setters, and the property method. It supports all property types, and both read-only and read/write properties.

The template can be downloaded from here. Once the file has been downloaded, simply do the following steps to import them into your IntelliJ IDEA:

Unzip the file and save settings.jar on the file system

In IntelliJ IDEA, click on the ‘File’ → ‘Import Settings…’

Locate settings.jar file on your file system

Restart IntelliJ IDEA, when prompted

Once the IDE has been restarted, from within your editor, you may simply type ‘fxprop‘, and a popup lets you choose the type of property you want. Once you press tab (or enter), the code for property is generated inside the editor. You can then immediately start typing the property name, and this will automatically update all the method names. Once you’ve done this, all you need to do is import the relevant classes.

3. IDE Plugins
Gluon releases IDE plugins for all major Java IDEs. These plugins can be used to create a basic project with all the required dependencies to natively build the project and ultimately run the native image. These plugins can be used to create either a Maven or Gradle project. We will briefly discuss on how to install these plugins, create a new project and build a native image using Gluon Client in the following section.

3.1. The Gluon Plugin for IntelliJ IDEA
In this section, we’ll explain briefly how to install the plugin on IntelliJ IDEA and how to use it to create a sample application that can be deployed on desktop, Android and iOS devices. Before we start, make sure to check the Platforms section for a list of prerequisites for each platform.

3.1.1. Plugin Installation
You can get it from here, or you can directly install it from IntelliJ IDEA: click File→Settings…​ (or IntelliJ IDEA→Preferences…​) and select Plugins on the left. You will see the installed plugins on your system.

Now click Marketplace, type Gluon, select the result and click Install.

Find Gluon Plugin
The Gluon Plugin will be downloaded and installed. Then press Restart IDE or simply press OK to close the plugins dialog, and restart the IDE when asked.

3.1.2. Create a new Gluon project
Once the plugin is installed, we can use it to create a sample application.

In IntelliJ IDEA, click File → New → Project…​ and select Gluon on the left, and one of the available projects on the right. For instance, Gluon Mobile - Single View Project. Press Next.

New Gluon Project
The first time you use the plugin, you will be asked to enter your email address.

Gluon Settings
If you already have a Gluon Mobile key for your projects, you can insert it here as well, so it will be added by default to your new projects. If you don’t, you will be using the free (trial) version. Please find more about Gluon Mobile licenses.

You can access these settings later on from File→Settings→Gluon (or IntelliJ IDEA→Preferences…​→Gluon):

Gluon Settings
Once you have completed this first-time-only form, click Next.

Type the package name and the main class name. Select the platforms to deploy the application, and the build tool of your choice. For this tutorial, we will use the Maven build tool. Press Next.

Package name
From the list, select a valid Java JDK (11+) and press Next.

Java JDK
Now add a name and a location for the project and press Finish.

Project name
The project will be imported and opened.

3.1.3. The Gluon Mobile project
The plugin already adds some default code in the main folder, so we’ll be able to run it without adding a single line of code.

The Maven project has a dependency on the OpenJFX Maven Plugin and the Gluon Client Maven plugin to the project.

These plugins add a series of goals and to access them we just need to open Maven tool window in IntelliJ IDEA. The Maven tool window shows all the available Maven plugins along with their respective goals.

IDEA Project
3.1.4. Run the application
Make sure JAVA_HOME is properly set: from the Maven tool window, select Maven Settings→Maven→Runner, click on browse Environment variables, and if JAVA_HOME is not included, add it.

Java Home
Before creating a native image, it’s easier to run the application first and verify that there are no errors.

Select Plugins → javafx → javafx:run from the Maven tool window. Verify that all the tasks are executed without errors, and the project runs fine on your desktop. Alternatively you can open the terminal (View→Tool Windows→Terminal) and run mvn javafx:run.

Now let’s make a slight change to the code. In the BasicView class, update the text of the label on line 20 to the following:

button.setOnAction(e -> label.setText("Hello from IntelliJ IDEA!"));
Run it again to see that the new message shows up on your desktop when you click the button.

Run Project
3.1.5. Create & run a native image of the application
In order to run the native image steps it is better to use a system terminal or the embedded terminal from your IDE. However, it is still possible to use the IDE’s Maven window for this.

Make sure you set the environment variable GRAALVM_HOME. Alternatively, you can add path to GraalVM installation directory by adding graalvmHome to the client-plugin configuration.

If you are running on Windows, you need to run all the Client goals from an x64 terminal.

Please check the prerequisites for Windows deployment.

However, you can use the terminal from IntelliJ for this. Go to File→Settings…​→Tools→Terminal, and change Shell path from cmd.exe to cmd.exe /k "<path to VS2019>\VC\Auxiliary\Build\vcvars64.bat.

If you are running from IDE, make sure that the mvn executable under path/to/IntelliJ/plugins/maven/lib/maven3/bin/ has exec permissions, or select a custom Maven installation by setting the Maven home directory from the Maven tool window, Maven Settings→Maven.

The Gluon Client plugin provides us various goals which are explained in detail earlier in the documentation. For this tutorial, we will be using the client:build goal to create a native image of the application.

Execute mvn client:build from the terminal, or, select Plugins → client → client:build goal from the Maven tool window.

This goal typically takes a couple of minutes to complete and may vary depending on the system. Once the goal is executed successfully, the native image can be run by executing client:run goal.

3.1.6. Create & install an Android native image
This part is only applicable for Linux.

Please check the prerequisites for Android deployment.

Now we are ready to deploy the same application on an Android device.

Go to Maven tool window, expand Profiles and check android. Make sure that all other profiles are unchecked. This will activate the pre-existing android profile.

Run mvn -Pandroid client:build from the terminal, or alternatively, execute the client:build goal from the Maven plugins section.

Once the native image is created, we need to package it into an apk before we can install it on a physical Android device.

Execute mvn -Pandroid client:package to create an apk. Once the goal is executed successfully, connect a physical device and install the native image by executing the mvn -Pandroid client:install goal.

When the installation ends successfully, run mvn -Pandroid client:run or find the application on your device and open it up:

Android app
3.1.7. Create & install an iOS native image
This part is only applicable for MacOS.

Please check the prerequisites for iOS deployment.

Now we are ready for deploying the same application on an iOS device.

Go to Maven tool window, expand Profiles and check ios. Make sure that all other profiles are unchecked. This will activate the pre-existing ios profile. All client goals will now target iOS platform.

Run mvn -Pios client:build from the terminal, or alternatively, execute the client:build goal from the Maven plugins section.

Once the goal is executed successfully, connect a physical device and run the native image on it by executing by executing mvn -Pios client:run.

iOS app
3.2. The Gluon Plugin for NetBeans
In this section, we’ll explain briefly how to install the Gluon plugin on Apache NetBeans and how to use it to create a sample application that can be deployed on desktop, Android and iOS devices. Before we start, make sure to check the Platforms section for a list of prerequisites for each platform.

3.2.1. Plugin Installation
You can get it from the Apache NetBeans plugin portal, or you can directly install it from NetBeans: click Tools → Plugins. Now select Available Plugins…​ and find Gluon Plugin.

Plugins Window
Select the plugin, click Install and follow the steps:

Install plugin
Accept the license and click Install. Click Continue when prompted:

Plugin warning
Wait until the Gluon Plugin is installed and click Finish.

Plugin installed
You will find the plugin under the Installed tab in the Plugins window.

3.2.2. Create a new Gluon project
Once the plugin is installed, we can use it to create a sample application.

In NetBeans, click File → New → Project…​ and select Gluon on the left, and one of the available projects on the right. For instance, Gluon Mobile - Single View Project. Press Next.

New Gluon Project
The first time you use the plugin, you will be asked to enter your email address.

Gluon Settings
If you already have a Gluon Mobile license key for your projects, you can insert them here as well, so they will be added by default to your new projects. If you don’t, you will be using the free (trial) version. Please find more about Gluon Mobile licenses.

You can access these settings later on from Tools→Options→Miscellaneous→Gluon (or NetBeans→Preferences…​→Miscellaneous→Gluon):

Gluon Settings
Once you have completed this first-time-only form, click Next.

Type the name of the project, find a proper location, add the package name and change the main class name if required. Select the platforms to deploy the application, and the build tool of your choice. For this tutorial, we will use the Maven build tool.

Project Settings
Press Finish and the project will be created and opened.

You will notice that a Maven project has been created with the pom containing profiles for the platforms you selected. These profiles make it easier to create native images targeted to each of these platforms.

3.2.3. The Gluon Mobile project
The plugin already adds some default code in the main folders, so we’ll be able to run it without adding a single line of code.

The Maven project has a dependency on the OpenJFX Maven Plugin and the Gluon Client Maven plugin to the project.

These plugins add a series of goals and to access them we just need to switch to the Navigator panel in NetBeans. The Navigator panel shows all the available Maven goals.

NetBeans Project
3.2.4. Run the application
Make sure the Maven default JDK is properly set to 11+. Tools→Options→Java→Maven (or NetBeans→Preferences…​→Java→Maven), set Default JDK to JDK 11+ (or click Manage Java Platfoms to add a new Platform if it doesn’t exist).

Default JDK
Before creating a native image, it’s easier to run the application first and verify that there are no errors.

Select Run project (F6) or select javafx:run from the Navigator. Verify that all the tasks are executed without errors, and the project runs fine on your desktop. Alternatively you can open the terminal (Tools→Open in Terminal) and run mvn javafx:run.

Let’s make a slight change to the code. In the BasicView class, update the text of the label on line 21 to the following:

button.setOnAction(e -> label.setText("Hello from NetBeans!"));
Run it again to see that the new message shows up on your desktop when you click the button.

Run Project
3.2.5. Create & run a native image of the application
In order to run the native image steps it is better to use a system terminal or the embedded terminal from your IDE. However, it is still possible to use the IDE’s Navigator window for this.

Make sure you set the environment variable GRAALVM_HOME. Alternatively, you can add path to GraalVM installation directory by adding graalvmHome to the client-plugin configuration.

If you are running on Windows, you need to run all the Client goals from a x64 terminal.

Please check the prerequisites for Windows deployment.

However, you can use the terminal from NetBeans for this (it requires Cygwin installed). On the terminal, run once cmd.exe /k "<path to VS2019>\VC\Auxiliary\Build\vcvars64.bat.

The Gluon Client plugin provides us various goals which are explained in details, earlier in the documentation. For this tutorial, we will be using the client:build goal to create a native image of the application.

Execute mvn client:build from the terminal, or, run the client:build goal from the Navigator with modifiers, and add Env.GRAALVM_HOME=/path/to/GraalVM.

This goal typically takes a couple of minutes to complete and may vary depending on the system. Once the goal is executed successfully, the native image can be run by executing client:run goal.

3.2.6. Create & install an Android native image
This part is only applicable for Linux.

Please check the prerequisites for Android deployment.

Now we are ready for deploying the same application on an Android device.

Right-click on the project and select Set Configuration and select android. This will activate the pre-existing android profile.

Run mvn -Pandroid client:build from the terminal, or, execute the client:build goal from the Navigator with modifiers, adding profile android, and Env.GRAALVM_HOME=/path/to/GraalVM.

Once the native image is created, we need to package it into an apk before we can install it on a physical Android device.

Execute mvn -Pandroid client:package to create an apk. Once the goal is executed successfully, connect a physical device and install the native image by executing the mvn -Pandroid client:install goal.

When the installation ends successfully, run mvn -Pandroid client:run or find the application on your device and open it up:

Android app
3.2.7. Create & install an iOS native image
This part is only applicable for MacOS.

Please check the prerequisites for iOS.

Now we are ready for deploying the same application on an iOS device.

Right-click on the project and select Set Configuration and select ios. This will activate the pre-existing ios profile.

Run mvn -Pios client:build from the terminal, or, execute the client:build goal from the Navigator with modifiers, adding profile ios, and Env.GRAALVM_HOME=/path/to/GraalVM.

Once the goal is executed successfully, connect a physical device and run the native image on it by executing by executing mvn -Pios client:run.

iOS app
3.3. The Gluon Plugin for Eclipse
In this section, we’ll explain briefly how to install the Gluon plugin on Eclipse IDE and how to use it to create a sample application that can be deployed on desktop, Android and iOS devices. Before we start, make sure to check the Platforms section for a list of prerequisites for each platform.

3.3.1. Plugin Installation
Eclipse Marketplace
The Gluon Plugin can be installed through the Eclipse Marketplace. You can install it from this link or directly open the Eclipse Marketplace from Eclipse→Help→Eclipse MarketPlace…​. Then type Gluon in the search field and press 'Go' to find the plugin.

Eclipse Marketplace
Press Install, accept the terms of the license agreement when prompted and press Finish to begin the installation of the plugin. Press Confirm to install the installation of the selected features, and Install anyway when prompted with an unsigned sofware warning.

The Gluon Plugin will be downloaded and installed.

When the installation is completed, Eclipse will ask you to restart your IDE for the changes to take effect.

You can now continue to Creating a new Gluon Project.

Update Site
Alternatively, you can install the Gluon Plugin by providing an update site.

Open Eclipse and choose Help → Install New Software…. Paste the following Update Site URL in the Work with: text field: http://download.gluonhq.com/tools/eclipse/release, and select Gluon Plug-in for Eclipse. Then proceed as indicated above.

3.3.2. Create a new Gluon project
Now that the plugin is installed, we can use it to create a sample application.

In Eclipse, click File → New → Project… and select one of the available projects under the Gluon category, for instance, Gluon Mobile - Single View Project and click Next.

New Gluon Project
The first time you use the plugin, you will be asked to enter your email address.

Gluon Settings
If you already have a Gluon Mobile license key for your projects, you can insert them here as well, so they will be added by default to your new projects. If you don’t, you will be using the free (trial) version. Please find more about Gluon Mobile licenses.

You can access these settings later on from Window→Preferences→Gluon (or Eclipse→Preferences…​→Gluon):

Gluon Settings
Once you have completed this first-time-only form, click Next.

Provide a name for the project, optionally choose a custom location to store the project and click Next.

Provide project name and location
The plugin will generate a JavaFX application class. In the following step you can configure the name of the package and the name of the class that will be generated. Select the platforms to deploy the application, and the build tool of your choice. For this tutorial, we will use the Maven build tool.

Provide package and class name and select platforms
Click Finish to complete the creation of the Gluon project.

You will notice that a Maven project has been created with the pom containing profiles for the platforms you selected. These profiles make it easier to create native images targeted to each of these platforms.

3.3.3. The Gluon Mobile project
The plugin already adds some default code in the main folders, so we’ll be able to run it without adding a single line of code.

Gluon project
The Maven project has a dependency on the OpenJFX Maven Plugin and the Gluon Client Maven plugin to the project. These plugins add a series of goals which will be used to run and create native images of the application.

3.3.4. Run the application
Before creating a native image, it’s easier to run the application first and verify that there are no errors.

Right-click on the project, select Run As → Maven Build…​. An "Edit Configuration" window opens. In the Goals textfield, type javafx:run and click Run. Verify that all the tasks are executed without errors, and the project runs fine on your desktop.

Show the Maven Build view
Let’s make a slight change to the code. In the BasicView class, update the text of the label on line 20 to the following:

button.setOnAction(e -> label.setText("Hello from Eclipse!"));
Run the application again to verify that the text inside the label has changed.

Run project
3.3.5. Create & run a native image of the application
In order to run the native image steps it is better to use a system terminal or the embedded terminal from your IDE. However, it is still possible to use the IDE’s Run Configurations dialog for this.

Make sure you set the environment variable GRAALVM_HOME. Alternatively, you can add path to GraalVM installation directory by adding graalvmHome to the client-plugin configuration.

If you are running on Windows, you need to run all the Client goals from a x64 terminal.

Please check the prerequisites for Windows deployment.

However, you can use the terminal from Eclipse for this (it can be installed from the Eclipse Marketplace). On the terminal, run once cmd.exe /k "<path to VS2019>\VC\Auxiliary\Build\vcvars64.bat.

The Gluon Client plugin has various goals which are explained in details earlier in the documentation. For this tutorial, we will be using the client:build goal to create a native image of the application.

Execute mvn client:build from the terminal, or, open the Run Configurations…​ window and update the Goal to client:build and click Run.

This goal typically takes a couple of minutes to complete and may vary depending on the system. Once the goal is executed successfully, the native image can be run by executing client:run goal.

3.3.6. Create & install an Android native image
This part is only applicable for Linux.

Please check the prerequisites for Android deployment.

Now we are ready for deploying the same application on an Android device.

Right-click on the project and open Maven → Select Maven Profiles…​ window. Check android checkbox and uncheck all others. This will activate the pre-existing android profile. All the client goals will now target android platform instead of desktop.

Run mvn -Pandroid client:build from the terminal, or alternatively, execute the client:build goal again, this time the android profile should be selected by default, else add it to the profiles field.

Once the native image is created, we need to package it into an apk before we can install it on a physical Android device.

Execute mvn -Pandroid client:package goal to create an apk. Once the goal is executed successfully, connect a physical device and install the native image by executing client:install goal.

Once the goal is executed successfully, connect a physical device and install the native image by executing the mvn -Pandroid client:install goal.

When the installation ends successfully, run mvn -Pandroid client:run or find the application on your device and open it up:

Android app
3.3.7. Create & install an iOS native image
This part is only applicable for MacOS.

Please check the prerequisites for iOS.

Now we are ready for deploying the same application on an iOS device.

Right-click on the project and open Maven → Select Maven Profiles…​ window. Check ios checkbox and uncheck all others. This will activate the pre-existing ios profile. All client goals will now target iOS platform.

Run mvn -Pios client:build from the terminal, or alternatively, execute the client:build goal again, this time the ios profile should be selected by default, else add it to the profiles field.

Once the goal is executed successfully, connect a physical device and run the native image on it by executing mvn -Pios client:run.

iOS app
4. The Gluon Client plugin for Maven
Any Java(FX) project can be easily integrated with Gluon. This section details the specifics of the Gluon Client Maven plugin and shows how to add it to your project, to create native applications.

Open Source
Client Maven plugin is open sourced, and licensed under the BSD-3 license. Its source code is hosted under Gluon organization in Github.

4.1. Apply the plugin
Edit your pom file and add the plugin:

<plugin>
    <groupId>com.gluonhq</groupId>
    <artifactId>client-maven-plugin</artifactId>
    <version>0.1.38</version>
    <configuration>
        <mainClass>your.mainClass</mainClass>
    </configuration>
</plugin>
The plugin allows some options that can be set in <configuration> to override the default settings.

4.2. Goals
The client plugin introduces the following goals:

client:compile

client:link

client:build

client:package

client:install

client:run

client:runagent

4.2.1. client:compile
This goal performs AOT compilation by executing the native-image command and builds the shared object file. It is a very intensive and lengthy task (several minutes, depending on your project and CPU), so it should be called only when the project is ready and runs fine on a VM.

The results will be available at target/client/$arch-$os/gvm.

4.2.2. client:link
Links the object file to create a native executable file or shared library.

The results will be available at target/client/$arch-$os/$AppName.

4.2.3. client:build
This goal simply combines client:compile and client:link.

4.2.4. client:package
Packages the executable or shared library into a target specific package that includes all the necessary dependencies.

The list of platform specific packages are as follows:

Linux - deb, rpm

macOS - app, pkg, deb

Windows - exe, msi

iOS - app, ipa

Android - apk

At the moment, this goal is only supported for iOS and Android.

4.2.5. client:install
Installs the package on the host system or attached device.

At the moment, this goal is only intended for Android.

4.2.6. client:run
Runs either the executable generated by client:link on the host system or runs the application that was installed on the device (iOS or Android).

4.2.7. client:runagent
Runs the project on desktop, in combination with the javafx-maven-plugin, with GraalVM’s JVM (HotSpot) and with the native-image-agent to record the behavior of the Java application and generate the configuration files for reflection, JNI, resource, proxy and serialization, that will be used by the native image generation with the above goals.

If needed, this goal should be executed before the others, and requires the user intervention to discover all reachable classes, by going through all possible scenes, views, dialogs, menus…​

This goal is not strictly needed, as the Client plugin already provides a basic set of configuration files that can be modified manually. In any case, the configuration files generated by the tracing agent will be picked and merged with those generated by the plugin (as in most cases the content of both will be duplicated).

Using the agent might have some impact in the native compilation time and the binary size.

Since: 0.1.37

4.3. Run the samples
There are many samples available in the Gluon-samples project on GitHub that make use of the Gluon Client plugin for Maven.

These docs only mention the getting started HelloWorld samples.

For the rest of the samples, see Gluon documentation website.

Before proceeding, make sure to set the JAVA_HOME environment variable to the same location as GRAALVM_HOME.

4.3.1. HelloWorld
Let’s run HelloWorld with the Gluon Client plugin for Maven.

HelloWorld.java
package hello;

public class HelloWorld {

    public static void main(String[] args) {
        System.out.println("Hello World!!");
        System.exit(0);
    }
}
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gluonhq.samples</groupId>
    <artifactId>helloworld</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>helloworld</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>s
        <maven.compiler.release>11</maven.compiler.release>
        <client.maven.plugin.version>3.8.1</client.maven.plugin.version>
        <main.class>hello.HelloWorld</main.class>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
            </plugin>

            <plugin>
                <groupId>com.gluonhq</groupId>
                <artifactId>client-maven-plugin</artifactId>
                <version>0.1.38</version>
                <configuration>
                    <target>${client.target}</target>
                    <mainClass>${main.class}</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <profile>
            <id>desktop</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <properties>
                <client.target>host</client.target>
            </properties>
        </profile>
        <profile>
            <id>ios</id>
            <properties>
                <client.target>ios</client.target>
            </properties>
        </profile>
        <profile>
            <id>android</id>
            <properties>
                <client.target>android</client.target>
            </properties>
        </profile>
    </profiles>
</project>
Target: Linux
On a Linux machine, run the client:compile goal. It produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ helloworld ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for x86_64-linux-linux. This may take some time.
[INFO] [SUB] [hello.helloworld:4902]    classlist:   2,318.99 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:4902]        (cap):   1,459.76 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:4902]        setup:   3,223.67 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:4902]     (clinit):     368.34 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]   (typeflow):  11,305.59 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]    (objects):  12,607.81 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]   (features):   1,637.68 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]     analysis:  26,435.19 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]     universe:     604.95 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]      (parse):   1,945.81 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:4902]     (inline):   3,643.57 ms,  4.15 GB
[INFO] [SUB] [hello.helloworld:4902]    (compile):  14,496.02 ms,  4.90 GB
[INFO] [SUB] [hello.helloworld:4902]      compile:  21,376.96 ms,  4.90 GB
[INFO] [SUB] [hello.helloworld:4902]        image:   2,728.50 ms,  4.90 GB
[INFO] [SUB] [hello.helloworld:4902]        write:     669.48 ms,  4.90 GB
[INFO] [SUB] [hello.helloworld:4902]      [total]:  57,617.30 ms,  4.90 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hello.helloworld.o is created and can be found under target/client/x86_64-linux/gvm/tmp/SVM-*/hello.helloworld.o.

Run the client:link goal to produce the native image.

As a result, target/client/x86_64-linux/helloWorld is created. It can be executed directly from a terminal or with mvn client:run.

HelloWorld Linux Link Output
Target: macOS
On Mac OS X, Run the client:compile goal. It produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ helloworld ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for x86_64-apple-darwin. This may take some time.
[INFO] [SUB] [hello.helloworld:1829]    classlist:   1,741.21 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:1829]        (cap):   1,604.12 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:1829]        setup:   3,875.26 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:1829]     (clinit):     512.37 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]   (typeflow):  13,551.23 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]    (objects):  14,683.72 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]   (features):   1,897.64 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]     analysis:  31,396.24 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]     universe:     927.88 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]      (parse):   3,290.32 ms,  3.21 GB
[INFO] [SUB] [hello.helloworld:1829]     (inline):   4,121.45 ms,  4.11 GB
[INFO] [SUB] [hello.helloworld:1829]    (compile):  24,163.64 ms,  5.02 GB
[INFO] [SUB] [hello.helloworld:1829]      compile:  33,199.90 ms,  5.02 GB
[INFO] [SUB] [hello.helloworld:1829]        image:   4,121.24 ms,  5.02 GB
[INFO] [SUB] [hello.helloworld:1829]        write:     697.29 ms,  5.02 GB
[INFO] [SUB] [hello.helloworld:1829]      [total]:  76,352.27 ms,  5.02 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hello.helloworld.o is created and can be found under target/client/x86_64-darwin/gvm/tmp/SVM-*/hello.helloworld.o.

Run the client:link goal to produce the native image. As a result, target/client/x86_64-darwin/helloWorld is created. It can be executed directly from a terminal or with mvn client:run.

HelloWorld macOS Link Output
Target: Windows
On a Windows machine, run the client:compile goal. It produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ helloworld ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for x86_64-microsoft-windows. This may take some time.
[INFO] [SUB] Warning: Ignoring server-mode native-image argument --no-server.
[INFO] [SUB] [hello.helloworld:7112]    classlist:   4,153.91 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:7112]        (cap):   5,358.45 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:7112]        setup:   8,726.61 ms,  0.96 GB
[INFO] [SUB] WARNING GR-10238: VarHandle for static field is currently not fully supported. Static field private static volatile java.lang.System$Logger jdk.internal.event.EventHelper.securityLogger is not properly marked for Unsafe access!
[INFO] [SUB] [hello.helloworld:7112]     (clinit):     418.10 ms,  1.92 GB
[INFO] [SUB] [hello.helloworld:7112]   (typeflow):  24,301.38 ms,  1.92 GB
[INFO] [SUB] [hello.helloworld:7112]    (objects):  22,462.70 ms,  1.92 GB
[INFO] [SUB] [hello.helloworld:7112]   (features):   1,743.55 ms,  1.92 GB
[INFO] [SUB] [hello.helloworld:7112]     analysis:  49,567.10 ms,  1.92 GB
[INFO] [SUB] [hello.helloworld:7112]     universe:     790.38 ms,  1.92 GB
[INFO] [SUB] [hello.helloworld:7112]      (parse):   6,963.45 ms,  1.82 GB
[INFO] [SUB] [hello.helloworld:7112]     (inline):   6,342.01 ms,  2.09 GB
[INFO] [SUB] [hello.helloworld:7112]    (compile):  32,776.16 ms,  2.09 GB
[INFO] [SUB] [hello.helloworld:7112]      compile:  47,301.62 ms,  2.09 GB
[INFO] [SUB] [hello.helloworld:7112]        image:   2,534.79 ms,  2.09 GB
[INFO] [SUB] [hello.helloworld:7112]        write:     227.90 ms,  2.09 GB
[INFO] [SUB] [hello.helloworld:7112]      [total]: 113,730.60 ms,  2.09 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hello.helloworld.obj is created and can be found under target\client\x86_64-windows\gvm\tmp\SVM-*\hello.helloworld.obj.

Run the client:link goal to produce the native image. As a result, target\client\x86_64-windows\helloWorld.exe is created. It can be executed directly or with mvn client:run.

HelloWorld Windows Link Output
Target: iOS
This requires an iOS device that has to be plugged in at the run phase. A valid provisioning profile is required as well, either by enrolling to the Apple Developer program or by using free provisioning. See iOS Deployment.

Use the ios profile to run mvn -Pios client:compile on Mac OS X:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ helloworld ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for arm64-apple-ios. This may take some time.
[INFO] [SUB] [hello.helloworld:2619]    classlist:   1,796.27 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:2619]        (cap):     394.97 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:2619]        setup:   2,588.74 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:2619]     (clinit):     501.74 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]   (typeflow):  12,836.03 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]    (objects):  14,296.39 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]   (features):   1,699.59 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]     analysis:  30,090.48 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]     universe:     956.49 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]      (parse):   3,090.59 ms,  3.18 GB
[INFO] [SUB] [hello.helloworld:2619]     (inline):   3,993.41 ms,  4.11 GB
[INFO] [SUB] [hello.helloworld:2619]    (compile):  28,280.20 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]    (bitcode):   1,210.45 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]    (prelink):   4,441.72 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]       (llvm):  52,067.97 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]   (postlink):   3,286.67 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]      compile:  96,697.84 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]        image:   4,741.68 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]        write:   1,412.67 ms,  4.95 GB
[INFO] [SUB] [hello.helloworld:2619]      [total]: 138,660.24 ms,  4.95 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hello.helloworld.o is created and can be found under target/client/arm64-ios/gvm/tmp/SVM-*/hello.helloworld.o.

Note that the process takes some time. There will be performance improvements, but either way, it is convenient to test first on desktop (and with HotSpot) as much as possible (i.e. with mvn javafx:run), so client:compile doesn’t have to be repeated due to avoidable errors.

Run the mvn -Pios client:link to produce the native image. As a result, target/client/arm64-ios/helloWorld.app is created.

HelloWorld iOS Link Output
Now it can be deployed to a plugged iOS device with mvn -Pios client:run.

HelloWorld iOS deployed
[INFO] --- client-maven-plugin:0.1.38:run (default-cli) @ helloworld ---
[INFO] ==================== RUN TASK ====================
[INFO] [SUB] [....] Waiting for iOS device to be connected
[INFO] [SUB] [....] Using abcdef01234567890abcdef01234567890abcdef (D221AP, iPhone X, iphoneos, arm64) a.k.a. 'iPhone'.
[INFO] [SUB] ------ Install phase ------
[INFO] [SUB] [  0%] Found abcdef01234567890abcdef01234567890abcdef (D221AP, iPhone X, iphoneos, arm64) a.k.a. 'iPhone' connected through USB, beginning install
[INFO] [SUB] [  5%] Copying ~/development/client-samples/Maven/HelloWorld/target/client/arm64-ios/helloWorld.app/META-INF/ to device
...
[INFO] [SUB] [ 90%] SandboxingApplication
[INFO] [SUB] [ 95%] GeneratingApplicationMap
[INFO] [SUB] [100%] Installed package ~/development/client-samples/Maven/HelloWorld/target/client/arm64-ios/helloWorld.app
...
[INFO] [SUB] ------ Debug phase ------
[INFO] [SUB] Starting debug of abcdef01234567890abcdef01234567890abcdef (D221AP, iPhone X, iphoneos, arm64) a.k.a. 'iPhone' connected through USB...
[INFO] [SUB] [  0%] Looking up developer disk image
[INFO] [SUB] [ 95%] Developer disk image mounted successfully
[INFO] [SUB] [100%] Connecting to remote debug server
[INFO] [SUB] -------------------------
...
[INFO] [SUB] determineCpuFeaures
[INFO] [SUB] Hello World!!
[INFO] [SUB] Process 23642 exited with status = 0 (0x00000000)
[INFO] result = true
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
Even though there is no UI for this application, we can still see the message being printed to the console.

Target: Android
This requires an Android device that has to be plugged in at the run phase.

On a Linux machine, use the android profile and run mvn -Pandroid client:compile:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ helloworld ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for aarch64-linux-android. This may take some time.
[INFO] [SUB] [hello.helloworld:8258]    classlist:   1,474.74 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:8258]        (cap):     306.46 ms,  0.96 GB
[INFO] [SUB] [hello.helloworld:8258]        setup:   2,078.26 ms,  0.96 GB
[INFO] [SUB] WARNING GR-10238: VarHandle for static field is currently not fully supported. Static field private static volatile java.lang.System$Logger jdk.internal.event.EventHelper.securityLogger is not properly marked for Unsafe access!
[INFO] [SUB] [hello.helloworld:8258]     (clinit):     493.75 ms,  2.29 GB
[INFO] [SUB] [hello.helloworld:8258]   (typeflow):  11,436.20 ms,  2.29 GB
[INFO] [SUB] [hello.helloworld:8258]    (objects):  12,928.51 ms,  2.29 GB
[INFO] [SUB] [hello.helloworld:8258]   (features):   1,578.28 ms,  2.29 GB
[INFO] [SUB] [hello.helloworld:8258]     analysis:  27,065.74 ms,  2.29 GB
[INFO] [SUB] [hello.helloworld:8258]     universe:     909.78 ms,  2.30 GB
[INFO] [SUB] [hello.helloworld:8258]      (parse):   2,156.71 ms,  2.30 GB
[INFO] [SUB] [hello.helloworld:8258]     (inline):   3,780.53 ms,  3.68 GB
[INFO] [SUB] [hello.helloworld:8258]    (compile):  19,433.23 ms,  4.72 GB
[INFO] [SUB] [hello.helloworld:8258]      compile:  26,877.82 ms,  4.72 GB
[INFO] [SUB] [hello.helloworld:8258]        image:   4,022.56 ms,  4.72 GB
[INFO] [SUB] [hello.helloworld:8258]        write:     409.92 ms,  4.72 GB
[INFO] [SUB] [hello.helloworld:8258]      [total]:  63,290.80 ms,  4.72 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hello.helloworld.o is created and can be found under target/client/aarch64-android/gvm/tmp/SVM-*/hello.helloworld.o.

Note that the process takes some time. There will be performance improvements, but either way, it is convenient to test first on desktop (and with HotSpot) as much as possible (i.e. with mvn javafx:run), so client:compile doesn’t have to be repeated due to avoidable errors.

Run mvn -Pandroid client:link to produce the native image. As a result, target/client/aarch64-android/libhelloWorld.so is created.

Finally, run mvn -Pandroid client:package to bundle the application into an Android APK that can be installed on a device.

It produces the following output:

[INFO] --- client-maven-plugin:{client-maven-plugin-version}:package (default-cli) @ helloworld ---
[INFO] ==================== PACKAGE TASK ====================
[INFO] Default Android manifest generated in ~/Gluon/gluon-samples/HelloWorld/target/client/aarch64-android/gensrc/android/AndroidManifest.xml.
Consider copying it to ~/Gluon/gluon-samples/HelloWorld/src/android/AndroidManifest.xml before performing any modification
[INFO] Default Android resources generated in ~/Gluon/gluon-samples/HelloWorld/target/client/aarch64-android/gensrc/android/res.
Consider copying them to ~/Gluon/gluon-samples/HelloWorld/src/android/res before performing any modification
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
This creates the apk package which is available at target/client/aarch64-android/gvm/helloworld.apk.

HelloWorld Android apk
Now we are ready to install and run the application on a plugged-in Android device. Run mvn -Pandroid client:install client:run to install and launch the application on the device.

HelloWorld Android Deployed
[INFO] --- client-maven-plugin:0.1.38:install (default-cli) @ helloworld ---
[INFO] ==================== INSTALL TASK ====================
[INFO]
[INFO] --- client-maven-plugin:0.1.38:run (default-cli) @ helloworld ---
[INFO] ==================== RUN TASK ====================
...
[INFO] [SUB] E/GraalGluon(11146):
[INFO] [SUB] E/GraalGluon(11146):
[INFO] [SUB] E/GraalGluon(11146): determineCpuFeaures
[INFO] [SUB] D/GraalCompiled(11146): Hello World!!
...
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
Even though there is no UI for this application, we can still see the message being printed to the console.

4.3.2. HelloFX
Now let’s run HelloFX, a simple JavaFX application.

HelloFX.java
public class HelloFX extends Application {

    public void start(Stage stage) {
        String javaVersion = System.getProperty("java.version");
        String javafxVersion = System.getProperty("javafx.version");
        Label label = new Label("Hello, JavaFX " + javafxVersion + ", running on Java " + javaVersion + ".");

        ImageView imageView = new ImageView(new Image(HelloFX.class.getResourceAsStream("/hellofx/openduke.png")));
        imageView.setFitHeight(200);
        imageView.setPreserveRatio(true);

        VBox root = new VBox(30, imageView, label);
        root.setAlignment(Pos.CENTER);

        Scene scene = new Scene(root, 640, 480);
        scene.getStylesheets().add(HelloFX.class.getResource("styles.css").toExternalForm());
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gluonhq.samples</groupId>
    <artifactId>hellofx</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>hellofx</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.release>11</maven.compiler.release>
        <javafx.version>15.0.1</javafx.version>
        <client.maven.plugin.version>3.8.1</client.maven.plugin.version>
        <main.class>hellofx.HelloFX</main.class>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
            </plugin>

            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.5</version>
                <configuration>
                    <mainClass>${main.class}</mainClass>
                </configuration>
            </plugin>

            <plugin>
                <groupId>com.gluonhq</groupId>
                <artifactId>client-maven-plugin</artifactId>
                <version>${client.maven.plugin.version}</version>
                <configuration>
                    <target>${client.target}</target>
                    <mainClass>${main.class}</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <profile>
            <id>desktop</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <properties>
                <client.target>host</client.target>
            </properties>
        </profile>
        <profile>
            <id>ios</id>
            <properties>
                <client.target>ios</client.target>
            </properties>
        </profile>
        <profile>
            <id>android</id>
            <properties>
                <client.target>android</client.target>
            </properties>
        </profile>
    </profiles>

</project>
Run the application to make sure everything works with Java 11:

mvn clean javafx:run
Target: Linux
On a Linux machine, run the client:compile goal. It produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ hellofx ---
[INFO] ==================== COMPILE TASK ====================
[INFO] [SUB] [hellofx.hellofx:4286]    classlist:   4,465.09 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:4286]        (cap):   1,578.18 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:4286]        setup:   3,635.99 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:4286]     (clinit):   1,148.59 ms,  4.02 GB
[INFO] [SUB] [hellofx.hellofx:4286]   (typeflow):  20,732.40 ms,  4.02 GB
[INFO] [SUB] [hellofx.hellofx:4286]    (objects):  22,106.29 ms,  4.02 GB
[INFO] [SUB] [hellofx.hellofx:4286]   (features):   3,153.63 ms,  4.02 GB
[INFO] [SUB] [hellofx.hellofx:4286]     analysis:  49,730.80 ms,  4.02 GB
[INFO] [SUB] [hellofx.hellofx:4286]     universe:   4,497.82 ms,  5.10 GB
[INFO] [SUB] [hellofx.hellofx:4286]      (parse):   4,921.35 ms,  5.10 GB
[INFO] [SUB] [hellofx.hellofx:4286]     (inline):   7,389.24 ms,  5.48 GB
[INFO] [SUB] [hellofx.hellofx:4286]    (compile):  26,684.64 ms,  5.79 GB
[INFO] [SUB] [hellofx.hellofx:4286]      compile:  41,273.83 ms,  5.78 GB
[INFO] [SUB] [hellofx.hellofx:4286]        image:   4,323.81 ms,  5.78 GB
[INFO] [SUB] [hellofx.hellofx:4286]        write:     761.30 ms,  5.78 GB
[INFO] [SUB] [hellofx.hellofx:4286]      [total]: 109,023.72 ms,  5.78 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hellofx.hellofx.o is created and can be found under target/client/x86_64-linux/gvm/tmp/SVM-*/hellofx.hellofx.o.

Run the client:link goal to produce the native image. As a result, target/client/x86_64-linux/hellofx is created. It can be executed directly or with mvn client:run.

HelloFX Linux Link Output
HelloFX Linux running
Target: macOS
On Mac OS X, run the client:compile goal. It produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ hellofx ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for x86_64-apple-darwin. This may take some time.
[INFO] [SUB] [hellofx.hellofx:2309]    classlist:   3,410.78 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:2309]        (cap):   1,509.86 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:2309]        setup:   3,863.89 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:2309]     (clinit):   1,257.74 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:2309]   (typeflow):  24,813.75 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:2309]    (objects):  25,161.07 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:2309]   (features):   3,090.12 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:2309]     analysis:  56,425.44 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:2309]     universe:   2,060.83 ms,  5.06 GB
[INFO] [SUB] [hellofx.hellofx:2309]      (parse):   6,364.53 ms,  5.06 GB
[INFO] [SUB] [hellofx.hellofx:2309]     (inline):   7,150.96 ms,  5.84 GB
[INFO] [SUB] [hellofx.hellofx:2309]    (compile):  43,871.39 ms,  5.93 GB
[INFO] [SUB] [hellofx.hellofx:2309]      compile:  61,332.73 ms,  5.93 GB
[INFO] [SUB] [hellofx.hellofx:2309]        image:   8,034.36 ms,  5.89 GB
[INFO] [SUB] [hellofx.hellofx:2309]        write:   1,337.65 ms,  5.89 GB
[INFO] [SUB] [hellofx.hellofx:2309]      [total]: 136,878.31 ms,  5.89 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hellofx.hellofx.o is created and can be found under target/client/x86_64-darwin/gvm/tmp/SVM-*/hellofx.hellofx.o.

Run the client:link goal to produce the native image. As a result, target/client/x86_64-darwin/hellofx is created. It can be executed directly or with mvn client:run.

HelloFX macOS Link Output
HelloFX macOS running
Target: Windows
On a Windows machine, run the client:compile goal. It produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ hellofx ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for x86_64-microsoft-windows. This may take some time.
[INFO] [SUB] Warning: Ignoring server-mode native-image argument --no-server.
[INFO] [SUB] [hellofx.hellofx:1872]    classlist:   4,129.20 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:1872]        (cap):   2,432.83 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:1872]        setup:   4,741.30 ms,  0.96 GB
[INFO] [SUB] WARNING GR-10238: VarHandle for static field is currently not fully supported. Static field private static volatile java.lang.System$Logger jdk.internal.event.EventHelper.securityLogger is not properly marked for Unsafe access!
[INFO] [SUB] [hellofx.hellofx:1872]     (clinit):     913.99 ms,  2.33 GB
[INFO] [SUB] [hellofx.hellofx:1872]   (typeflow):  47,466.16 ms,  2.33 GB
[INFO] [SUB] [hellofx.hellofx:1872]    (objects):  30,559.65 ms,  2.33 GB
[INFO] [SUB] [hellofx.hellofx:1872]   (features):   2,596.89 ms,  2.33 GB
[INFO] [SUB] [hellofx.hellofx:1872]     analysis:  83,244.37 ms,  2.33 GB
[INFO] [SUB] [hellofx.hellofx:1872]     universe:   2,483.86 ms,  2.31 GB
[INFO] [SUB] [hellofx.hellofx:1872]      (parse):  12,910.54 ms,  2.07 GB
[INFO] [SUB] [hellofx.hellofx:1872]     (inline):  21,259.04 ms,  2.61 GB
[INFO] [SUB] [hellofx.hellofx:1872]    (compile):  51,522.36 ms,  2.83 GB
[INFO] [SUB] [hellofx.hellofx:1872]      compile:  88,166.40 ms,  2.83 GB
[INFO] [SUB] [hellofx.hellofx:1872]        image:   5,539.33 ms,  2.78 GB
[INFO] [SUB] [hellofx.hellofx:1872]        write:     461.00 ms,  2.78 GB
[INFO] [SUB] [hellofx.hellofx:1872]      [total]: 189,148.96 ms,  2.78 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hellofx.hellofx.obj is created and can be found under target\client\x86_64-windows\gvm\tmp\SVM-*\hellofx.hellofx.obj.

Run the client:link goal to produce the native image. As a result, target\client\x86_64-windows\hellofx.exe is created. It can be executed directly or with mvn client:run.

HelloFX Windows Link Output
HelloFX Windows running
Target: iOS
This requires an iOS device that has to be plugged in at the run phase. A valid provisioning profile is required as well, either by enrolling to the Apple Developer program or by using free provisioning. See iOS Deployment.

On Mac OS X, use the ios profile and run mvn -Pios client:compile, that produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ hellofx ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for arm64-apple-ios. This may take some time.
[INFO] [SUB] [hellofx.hellofx:3374]    classlist:   3,413.81 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:3374]        (cap):     415.26 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:3374]        setup:   2,741.93 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:3374]     (clinit):   1,281.87 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:3374]   (typeflow):  23,706.05 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:3374]    (objects):  23,952.72 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:3374]   (features):   2,950.68 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:3374]     analysis:  54,112.42 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:3374]     universe:   1,903.63 ms,  4.75 GB
[INFO] [SUB] [hellofx.hellofx:3374]      (parse):   6,064.08 ms,  5.06 GB
[INFO] [SUB] [hellofx.hellofx:3374]     (inline):  13,531.61 ms,  5.78 GB
[INFO] [SUB] [hellofx.hellofx:3374]    (compile):  52,150.30 ms,  5.71 GB
[INFO] [SUB] [hellofx.hellofx:3374]    (bitcode):   3,122.43 ms,  5.71 GB
[INFO] [SUB] [hellofx.hellofx:3374]    (prelink):  14,080.96 ms,  5.71 GB
[INFO] [SUB] [hellofx.hellofx:3374]       (llvm): 112,011.52 ms,  5.65 GB
[INFO] [SUB] [hellofx.hellofx:3374]   (postlink):   7,265.98 ms,  5.65 GB
[INFO] [SUB] [hellofx.hellofx:3374]      compile: 208,869.95 ms,  5.65 GB
[INFO] [SUB] [hellofx.hellofx:3374]        image:  12,751.53 ms,  5.56 GB
[INFO] [SUB] [hellofx.hellofx:3374]        write:   2,411.88 ms,  5.56 GB
[INFO] [SUB] [hellofx.hellofx:3374]      [total]: 286,614.27 ms,  5.56 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hellofx.hellofx.o is created and can be found under target/client/arm64-ios/gvm/tmp/SVM-*/hellofx.hellofx.o.

Run mvn -Pios client:link to produce the native image. As a result, target/client/arm64-ios/hellofx.app is created.

HelloFX iOS Link Output
Now it can be deployed to a plugged iOS device with mvn -Pios client:run.

HelloFX iOS deployed
Target: Android
This requires an Android device that has to be plugged in at the run phase.

On a Linux machine, use the android profile, and run mvn -Pandroid client:compile, that produces the following output:

[INFO] --- client-maven-plugin:0.1.38:compile (default-cli) @ hellofx ---
[INFO] ==================== COMPILE TASK ====================
[INFO] We will now compile your code for aarch64-linux-android. This may take some time.
[INFO] [SUB] [hellofx.hellofx:9119]    classlist:   3,089.42 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:9119]        (cap):     328.79 ms,  0.96 GB
[INFO] [SUB] [hellofx.hellofx:9119]        setup:   2,140.79 ms,  0.96 GB
[INFO] [SUB] WARNING GR-10238: VarHandle for static field is currently not fully supported. Static field private static volatile java.lang.System$Logger jdk.internal.event.EventHelper.securityLogger is not properly marked for Unsafe access!
[INFO] [SUB] [hellofx.hellofx:9119]     (clinit):     991.74 ms,  4.62 GB
[INFO] [SUB] [hellofx.hellofx:9119]   (typeflow):  16,071.52 ms,  4.62 GB
[INFO] [SUB] [hellofx.hellofx:9119]    (objects):  17,823.50 ms,  4.62 GB
[INFO] [SUB] [hellofx.hellofx:9119]   (features):   2,687.95 ms,  4.62 GB
[INFO] [SUB] [hellofx.hellofx:9119]     analysis:  38,896.58 ms,  4.62 GB
[INFO] [SUB] [hellofx.hellofx:9119]     universe:   1,839.74 ms,  4.62 GB
[INFO] [SUB] [hellofx.hellofx:9119]      (parse):   6,003.11 ms,  4.96 GB
[INFO] [SUB] [hellofx.hellofx:9119]     (inline):   8,276.27 ms,  5.90 GB
[INFO] [SUB] [hellofx.hellofx:9119]    (compile):  43,421.83 ms,  5.86 GB
[INFO] [SUB] [hellofx.hellofx:9119]      compile:  60,386.00 ms,  5.86 GB
[INFO] [SUB] [hellofx.hellofx:9119]        image:   7,353.86 ms,  5.90 GB
[INFO] [SUB] [hellofx.hellofx:9119]        write:     593.95 ms,  5.90 GB
[INFO] [SUB] [hellofx.hellofx:9119]      [total]: 114,908.43 ms,  5.90 GB
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
And as a result, hellofx.hellofx.o is created and can be found under target/client/aarch64-android/gvm/tmp/SVM-*/hellofx.hellofx.o.

Note that the process takes some time. There will be performance improvements, but either way, it is convenient to test first on desktop (and with HotSpot) as much as possible (i.e. with mvn javafx:run), so client:compile doesn’t have to be repeated due to avoidable errors.

Run mvn -Pandroid client:link to produce the native image. As a result, target/client/aarch64-android/libhellofx.so is created.

Finally, run mvn -Pandroid client:package to bundle the application into an Android APK that can be installed on a device.

It produces the following output:

[INFO] --- client-maven-plugin:{client-maven-plugin-version}:package (default-cli) @ hellofx ---
[INFO] ==================== PACKAGE TASK ====================
[INFO] Default Android manifest generated in ~/Gluon/gluon-samples/HelloFX/target/client/aarch64-android/gensrc/android/AndroidManifest.xml.
Consider copying it to ~/Gluon/gluon-samples/HelloFX/src/android/AndroidManifest.xml before performing any modification
[INFO] Default Android resources generated in ~/Gluon/gluon-samples/HelloFX/target/client/aarch64-android/gensrc/android/res.
Consider copying them to ~/Gluon/gluon-samples/HelloFX/src/android/res before performing any modification
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
This creates the apk package which is available at target/client/aarch64-android/gvm/hellofx.apk.

HelloWorld Android apk
Now we are ready to install and run the application on a plugged-in Android device. Run mvn -Pandroid client:install client:run to install and launch the application on the device.

HelloFX Android Running
4.4. Configuration
This is for advanced users.

The plugin allows some customization to modify the default settings, which are:

<plugin>
    <groupId>com.gluonhq</groupId>
    <artifactId>client-maven-plugin</artifactId>
    <version>0.1.38</version>
    <configuration>
        <target>host</target>
        <mainClass>your.mainClass</mainClass>
        <bundlesList></bundlesList>
        <resourcesList></resourcesList>
        <reflectionList></reflectionList>
        <jniList></jniList>
        <attachList></attachList>
        <nativeImageArgs></nativeImageArgs>
        <verbose>false</verbose>
        <graalvmHome></graalvmHome>
        <javaStaticSdkVersion>11-ea+1</javaStaticSdkVersion>
        <javafxStaticSdkVersion>11-ea+1</javafxStaticSdkVersion>
        <enableSWRendering>false</enableSWRendering>
        <releaseConfiguration>
            <!-- Android -->
            <appLabel></appLabel>
            <versionCode>1</versionCode>
            <versionName>1.0</versionName>
            <providedKeyStorePath>${android-keystore-path}</providedKeyStorePath>
            <providedKeyStorePassword>${android-keystore-password}</providedKeyStorePassword>
            <providedKeyAlias>${android-key-alias}</providedKeyAlias>
            <providedKeyAliasPassword>${android-key-password}</providedKeyAliasPassword>
            <!-- iOS -->
            <bundleName></bundleName>
            <bundleVersion>1.0</bundleVersion>
            <bundleShortVersion>1.0</bundleShortVersion>
            <providedSigningIdentity></providedSigningIdentity>
            <providedProvisioningProfile></providedProvisioningProfile>
            <skipSigning>false</skipSigning>
        </releaseConfiguration>
    </configuration>
</plugin>
4.4.1. target
A string that defines the target platform. The default is host, which refers to the platform that currently hosts the process. It can be set also to ios to create native images for iOS devices (Aarch64), or android to create native images for Android devices (Aarch64).

Default: host

4.4.2. bundlesList
List of fully qualified resource bundles that will be added to the default list of resource bundles. By default, the list already includes the JavaFX bundles, like:

com/sun/javafx/scene/control/skin/resources/controls

com/sun/javafx/scene/control/skin/resources/controls-nt

com.sun.javafx.tk.quantum.QuantumMessagesBundle

For more advanced usage, read the Resource bundles section.

4.4.3. resourcesList
List of additional resource patterns or extensions that will be added to the default resource list that already includes:

png, jpg, jpeg, gif, bmp, ttf, raw

xml, fxml, css, gls, json, dat,

license, frag, vert, obj

We keep adding extensions to this list. Please check the source code for the latest list.

For more advanced usage, read the Resources section.

4.4.4. reflectionList
List of additional full qualified classes that will be added to the default reflection list, that already includes most of the JavaFX classes.

Note: The current list is added to a file that can be found under target/client/$arch-$os/gvm/reflectionconfig-$arch-$os.json.

For more advanced usage, read the JNI and Reflection section.

4.4.5. jniList
List of additional full qualified classes that will be added to the default jni list, that already includes most of the JavaFX classes.

Note: The current list is added to a file that can be found under target/client/$arch-$os/gvm/jniconfig-$arch-$os.json.

For more advanced usage, read the JNI and Reflection section.

4.4.6. attachList
If you want to include Gluon Attach services to your project, you can use attachList to including the name of the services, like:

<!-- dependencies -->
<dependency>
    <groupId>com.gluonhq.attach</groupId>
    <artifactId>display</artifactId>
    <version>4.0.10</version>
</dependency>

<!-- plugin -->
<configuration>
    <attachList>
        <list>display</list>
    </attachList>
</configuration>
By default the attachVersion is 4.0.10.

After saving the changes, the dependencies for the defined services will be resolved to include those for defined target, and when the native compile goal is executed, the native services implementations will be added to the reflection and JNI lists.

Note: Attach platform implementations will be added only to the goals of the Client plugin, but not to the JavaFX plugin. It is convenient to use Maven profiles to overcome this issue.

4.4.7. nativeImageArgs
List of additional arguments that will be added to the native image creation.

4.4.8. verbose
Set to true will generate a more verbose output to the console, useful when having errors, to identify possible issues.

Also, you can get a more verbose output for these goals running with -X:

mvn -X client:compile
Default: false

Note: Regardless the verbose value, the full logs can be found under target/client/$arch-$os/gmv/log.

4.4.9. graalvmHome
Path to GraalVM installation directory. This is only required when GRAALVM_HOME is not set.

Since: 0.1.3

4.4.10. javaStaticSdkVersion
The version of the Java static libraries. These will be located under: ~/.gluon/substrate/javaStaticSdk/$javaStaticSdkVersion/$target-$arch/labs-staticjdk/lib.

Default: 11-ea+1

4.4.11. javafxStaticSdkVersion
The version of the JavaFX SDK and its static libraries. These will be located under: ~/.gluon/substrate/javafxStaticSdk/$javaStaticSdkVersion/$target-$arch/sdk/lib.

Default: 16-ea+gvm31

4.4.12. Software Rendering
JavaFX applications can use software rendering when the graphics hardware on a system is insufficient to support hardware accelerated rendering. To enable software rendering set the enableSWRendering parameter to true in plugin configuration.

Note: Enabling software rendering will result in a longer compile time and larger native image.

Default: false

Since: 0.1.14

4.5. Config files
Some configuration options can alternatively be defined in configuration files instead of the configuration section of the plugin.

There are two non-exlusive options to create these configuration files.

4.5.1. Files from tracing agent
Running the client:runagent goal, the following files will be created automatically by a tracing agent under src/main/resources/META-INF/native-image folder:

jni-config.json

proxy-config.json

reflect-config.json

resource-config.json

serialization-config.json

The files can be edited and modified to include or exclude content if needed.

The agent runs only on desktop, therefore only the classes for that host are discovered and added to the above config files. However, running on other platforms these might not be available. For that reason, the agent already filters out some of them (which are provided with the Substrate configuration files mentioned below). But if needed, these files can be edited and modified manually before running the Client goals.

4.5.2. Substrate config files
Alternatively, or in combination with the above, the configuration files detailed below can be used, and should be placed in a folder named src/main/resources/META-INF/substrate/config.

When building the application, the plugin will also inspect every jar dependency for the existence of these configuration files. The files in the jar should be placed in the same folder: META-INF/substrate/config.

JNI and Reflection
For every class that is defined in jniList or reflectionList, it is included in the configuration files target/client/$arch-$os/gvm/jniconfig-$arch-$os.json and target/client/$arch-$os/gvm/reflectionconfig-$arch-$os.json respectively, with a definition like the following:

[
  {
    "name" : "package.name.ClassName",
    "allDeclaredConstructors" : true,
    "allPublicConstructors" : true,
    "allDeclaredFields" : true,
    "allPublicFields" : true,
    "allDeclaredMethods" : true,
    "allPublicMethods" : true
  }
]
This has an impact on both compilation time and memory footprint, because all methods and fields are opened. Ideally, it is better to open only the minimal list of fields and methods that are required for your application to run.

You can create the following files:

jniconfig.json and/or reflectionconfig.json: these are applied to all targets

jniconfig-$arch-$os.json and/or reflectionconfig-$arch-$os.json: these are only applied to targets that match both the architecture and operating system. For example, specifying reflection configuration for linux 64bit can be achieved by creating a file called reflectionconfig-x86_64-linux.json.

The files must contain the fully qualified name of classes, together with some attributes (like allDeclaredFields), methods and/or fields that will be invoked via reflection and that are not already part of the list.

For instance, the configuration below only adds the method named valueOf of the MaterialDesignIcon class to the final reflection configuration:

[
  {
    "name":"com.gluonhq.charm.glisten.visual.MaterialDesignIcon",
    "methods":[
      {"name":"valueOf","parameterTypes":["java.lang.String"] }
    ]
  }
]
For more information, see Reflection use in Native Images.

Resources
The resourcesList configuration option can also be defined in a configuration file:

resourceconfig.json: applied to all targets

resourceconfig-$arch-$os.json: only applied to targets that match the given architecture and operating system

For more information, see Accessing resources in Native Images.

For instance, the configuration below includes a pattern to load all *.txt files found:

[
  {
  "resources": [
    {"pattern": ".*\\.txt$"}
  ]
  }
]
Resource bundles
The bundlesList configuration option can also be defined in a configuration file:

resourcebundles.json: applied to all targets

resourcebundles-$arch-$os.json: only applied to targets that match the given architecture and operating system

For instance, below are the fully qualified name of two given resource bundles that will be included:

com.mycompany.myproject.mybundle1
com.mycompany.myproject.mybundle2
Build time initialization
If you need to set a class or list of classed to be initialized at build time, you can add their fully qualified name to the following configuration files:

initbuildtime: applied to all targets

initbuildtime-$arch-$os: only applied to targets that match the given architecture and operating system

This can be especially convenient for enums that have a large list of values.

For more information, see Class initialization in Native Image.

4.6. Release Configuration
These options allow setting release parameters for Android and iOS.

4.6.1. Android
appLabel
A user-visible short name for the app, if not set, the Maven project’s name will be used.

versionCode
A positive integer used as an internal version number, by default is set to 1.

versionName
A string used as the version number shown to users, like <major>.<minor>.<point>. By default is 1.0.

Signing for release:
If these 4 parameters are not set, the app will be signed for debug only.

providedKeyStorePath: A string with the path to a keystore file that can be used to sign the Android apk

providedKeyStorePassword: A string with the password of the provide keystore file

providedKeyAlias: A string with an identifying name for the key

providedKeyAliasPassword: A string with a password for the key

Note that it can be convenient to define the values for these options in the ~/.m2/settings.xml file, using Maven profiles.

4.6.2. iOS
bundleName
A user-visible short name for the bundle. If not set, the Maven project’s name will be used.

bundleVersion
The version of the build that identifies an iteration of the bundle. A string composed of one to three period-separated integers, containing numeric characters (0-9) and periods only. Default 1.0.

bundleShortVersion
A user-visible string for the release or version number of the bundle. A string composed of one to three period-separated integers, containing numeric characters (0-9) and periods only. Default 1.0.

Signing for development or distribution
providedSigningIdentity: String that identifies a valid certificate that will be used for iOS development or iOS distribution.

providedProvisioningProfile: String with the name of the provisioning profile created for iOS. When not provided, the plugin will be selected from all the valid identities found installed on the machine from any of these types:

iPhone Developer|Apple Development|iOS Development|iPhone Distribution
and that were used by the provisioning profile development or distribution of the given app. When not provided, the plugin will try to find a valid installed provisioning profile that can be used to sign the app, including wildcards.

skipSigning
Boolean that can be used to skip signing iOS apps. This will prevent any deployment, but can be useful to run tests without an actual device.

5. Platforms
Gluon applications can run on various platforms. These applications can run directly on the JVM on all desktop and embedded platforms without any additional requirement.

Gluon applications can also be converted to native-image to target a specific platform. Few native-image targets have a dependency on the platform on which they can be built. For example, iOS images can currently be only produced on a MacOS.

Native-images can be created for desktop and mobile platforms. Embedded platform support will be added soon.
In this section, we will discuss the requirements, procedure, and restrictions for development and deployment of Gluon applications across platforms.

Gluon builds for a specific client platform are required to run a specific host platform (e.g. Windows native build has to run on Windows, an iOS native build have to run on macOS). This hurdle can be overcome by using a build automation tool like Github Actions, which provides build 'runners' for every major OS. Each platform section below contains an example Github Actions Workflow for that platform. You can also have a look at the Hello Gluon CI Sample which combines a workflow for all supported platforms.

5.1. Linux
Gluon applications can run on JVM without any additional requirement. However, to create native-images for your Gluon application, you will need the latest version of GraalVM.

The latest version of GraalVM can be downloaded from https://github.com/graalvm/graalvm-ce-builds/releases/tag/vm-21.0.0.

Set the GRAALVM_HOME environment variable to point to the GraalVM directory:

export GRAALVM_HOME=/path/to/graalvm-ce-java11-21.0.0
In addition to GraalVM, the following packages are also required:

gcc version 6 or higher

ld version 2.26 or higher

5.1.1. CentOS
Required packages
Execute the following command to install the required yum packages:

sudo yum install pkgconfig gtk3-devel libXtst-devel
CentOS 6/7: Developer Toolset
By default, CentOS 6 and 7 bundle gcc version 4.4.x and 4.8.x respectively. The easiest way to install a more recent version is to install Developer Toolset 6 or higher using Software Collections. The installation process is described in detail at: https://www.softwarecollections.org/en/scls/rhscl/devtoolset-8/

5.1.2. Linux native builds using Github Actions
Using this Github workflow, you can checkout, build, and upload the native binary as a build artifact. The steps are described in code comments:

jobs:
build:
    runs-on: ubuntu-latest
    steps:
        # Checkout your code
        - uses: actions/checkout@v2

        # Make sure the latest GraalVM is installed.
        # after this step env.JAVA_HOME will point to the GraalVM location
        - name: Setup GraalVM environment
            uses: DeLaGuardo/setup-graalvm@master
            with:
            graalvm-version: 21.0.0.java11

        # Install extra required packaged on top of ubuntu-latest
        - name: Install libraries
            run: sudo apt install libasound2-dev libavcodec-dev libavformat-dev libavutil-dev libgl-dev libgtk-3-dev libpango1.0-dev libxtst-dev

        # Create a staging directory where the binary will be copied into
        - name: Make staging directory
            run: mkdir staging

        # Build your project using Maven
        # The desktop profile is used, which means a native build will be created for the host platform (in this case Linux) itself.
        - name: Gluon Build
            run: mvn -Pdesktop client:build client:package
            env:
            GRAALVM_HOME: ${{ env.JAVA_HOME }}


        # Copy the native binary to the staging directory
        - name: Copy native client to staging
            run: cp -r target/client/x86_64-linux/HelloGluon staging


        # Upload the staging directory as a build artifact. You will be able to download this after the build finishes.
        - name: Upload
            uses: actions/upload-artifact@v2
            with:
            name: Package
            path: staging
